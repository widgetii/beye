 ARM (Advanced RISC Machine, and prior to that Acorn RISC Machine)
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ %BARM Summary%b                                                             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                                                                         ³
³ %IDescription%i                                                             ³
³                                                                         ³
³ The ARM is a 32-bit RISC processor architecture developed by ARM Limited³
³ that is widely used in embedded designs. Because of their power saving  ³
³ features, ARM CPUs are widely present in the mobile electronics market, ³
³ where low power consumption is a critical design goal.                  ³
³                                                                         ³
³ The ARM design was started in 1983 as a development project at Acorn    ³
³ Computers Ltd to build a compact RISC CPU. They completed development   ³
³ samples called ARM1 by April 1985, and the first %Ireal%i production systems³
³ as ARM2 the following year.                                             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ ARM has 16 visible general-purpose 32-bit registers:                    ³
³ %IR0-R8%i  - unbanked registers                                             ³
³ %IR8-R12%i - banked registers                                               ³
³ %IR13(SP)%i- normally used as Stack Pointer and is also known as the SP     ³
³ %IR14(LR)%i- normally used as Link Register and is also known as the LR     ³
³ %IR15(PC)%i- normally used as Program Counter register                      ³
³                                                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ There also are two special registers:                                   ³
³                                                                         ³
³ %ICPSR%i   - current program status register                                ³
³ %ISPSR%i   - saved program status register                                  ³
³ Format of these registers:                                              ³
³     31 30 29 28 27 26         8 7 6 5 4 3 2 1 0                         ³
³    ÚÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿                        ³
³    ³  ³  ³  ³  ³  ³            ³ ³ ³ ³M³M³M³M³M³                        ³
³    ³ N³ Z³ C³ V³ Q³   DNM(RAZ) ³I³F³T³4³3³2³1³0³                        ³
³    ÀÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ                        ³
³ %IN%i      - Negative flag                                                  ³
³ %IZ%i      - Zero flag                                                      ³
³ %IC%i      - Carry flag                                                     ³
³ %IV%i      - oVerflow flag                                                  ³
³ %IQ%i      - saturation flag in Qxxx insns or overflow in SMLAxy insns      ³
³ %IRAZ%i    - Reserved Always Zero bits                                      ³
³ %II%i      - disable IRQ interrupts                                         ³
³ %IF%i      - disable FIQ interrupts                                         ³
³ %IT%i      - Thumb mode of instructions                                     ³
³ %IM[4:0]%i - Determine mode of processor:                                   ³
³  %B10000%b - User mode (PC, R0-R14, CPSR are accesible)                     ³
³  %B10001%b - FIQ mode                                                       ³
³  %B10010%b - IRQ mode                                                       ³
³  %B10011%b - Supervisor mode                                                ³
³  %B10111%b - Abort mode                                                     ³
³  %B11011%b - Undefined mode                                                 ³
³  %B11111%b - System mode                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ %IInstruction set encoding:%i                                               ³
³                                                                         ³
³ All instructions in ARM architecture are 4-byte long. The fields of     ³
³ instruction are located as follow:                                      ³
³                                                                         ³
³    31-28 27-25 24-21  20 19-16 15-12 11-7  6-5   4  3-0                 ³
³   ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÂÄÄÂÄÄÄ¿                ³
³   ³cond ³ext  ³opcode³S ³  Rn ³ Rd  ³ Rs ³ Shift³X ³Rm ³                ³
³   ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÅÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÂÁÄÄÄÄÄÄÁÄÄÅÄÄÄ´                ³
³   ³cond ³ext  ³opcode³S ³  Rn ³ Rd  ³ Rs³ XXXXXXX  ³Rm ³                ³
³   ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÅÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÁÂÄÄÄÄÄÄÄÄÄÁÄÄÄ´                ³
³   ³cond ³ext  ³opcode³S ³  Rn ³ Rd  ³ rot³  Immediate  ³                ³
³   ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÅÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄ´                ³
³   ³cond ³ext  ³opcode³S ³  Rn ³ Rd  ³   Immediate      ³                ³
³   ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÅÄÄÄÄÄÅÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                ³
³   ³cond ³ext  ³opcode³S ³  Rn ³   Register list        ³                ³
³   ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                ³
³   ³cond ³ext  ³        24-bit offset or SWI number     ³                ³
³   ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                ³
³ Due architecture limitation branch instruction can specify %I+-32MB%i only  ³
³                                                                         ³
³ cond   - means condition of instruction execution                       ³
³ ext    - high part of extended opcode                                   ³
³ opcode - opcode itself                                                  ³
³ S      - means modification of CPSR                                     ³
³ Rn     - specifies first operand of operation                           ³
³ Rd     - specifies destinition register                                 ³
³ Rs     - specifies shifter register                                     ³
³ Rm     - specifies multiplier register                                  ³
³ Rg lst - specifies list of registers for some insns                     ³
³ S - means modification of CPSR                                          ³
³ X - low part of extended opcode if present                              ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Almost all ARM instructions can be conditionally executed, which means  ³
³ that they only have their normal effect on the programmer's model state,³
³ memory and coprocessors if the %IN%i, %IZ%i, %IC%i and %IV%i flags in the %ICPSR%i satisfy a³
³ condition specified in the instruction. If the flags do not satisfy this³
³ condition, the instruction acts as a %INOP%i: that is, execution advances to³
³ the next instruction as normal, including any relevant checks for       ³
³ interrupts and prefetch aborts, but has no other effect.                ³
³                                                                         ³
³ Condition encoding:                                                     ³
³ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿     ³
³³31:28³exten³ Meaning                          ³ Condition flag    ³     ³
³ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´     ³
³³0000 ³  EQ ³ Equal                            ³Z=1                ³     ³
³³0001 ³  NE ³ Not equal                        ³Z=0                ³     ³
³³0010 ³CS/HS³ Carry set/unsigned higher or same³C=1                ³     ³
³³0011 ³CC/LO³ Carry clear/unsigned lower       ³C=0                ³     ³
³³0100 ³  MI ³ Minus/negative                   ³N=1                ³     ³
³³0101 ³  PL ³ Plus/positive or zero            ³N=0                ³     ³
³³0110 ³  VS ³ Overflow                         ³V=1                ³     ³
³³0111 ³  VC ³ No overflow                      ³V=0                ³     ³
³³1000 ³  HI ³ Unsigned higher                  ³C=1 && Z=0         ³     ³
³³1001 ³  LS ³ Unsigned lower or same           ³C=0 || Z=1         ³     ³
³³1010 ³  GE ³ Signed greater than or equal     ³N=1 && V=1 or N==V ³     ³
³³1011 ³  LT ³ Signed less than                 ³N=1 && V=0 or N!=V ³     ³
³³1100 ³  GT ³ Signed greater than              ³Z=0 || N==V        ³     ³
³³1101 ³  LE ³ Signed less than or equal        ³Z=1 || N!=V        ³     ³
³³1110 ³  AL ³ Always (unconditional)           ³-                  ³     ³
³³1111 ³ (NV)³ Not valid except some cases      ³                   ³     ³
³ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ     ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ %IThumb instruction set encoding:%i                                         ³
³ The Thumb instruction set is a re-encoded subset of the ARM instruction ³
³ set. Thumb is designed to increase the performance of ARM               ³
³ implementations that use a 16-bit or narrower memory data bus and to    ³
³ allow better code density than ARM. T variants of the ARM architecture  ³
³ incorporate both a full 32-bit ARM instruction set and the 16-bit Thumb ³
³ instruction set. Every Thumb instruction is encoded in 16 bits:         ³
³                                                                         ³
³ 15-13 12-11  10      6 5     3 2    0   Here:                           ³
³ÚÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿                                  ³
³³ ext ³opcode³immediate³   Rm  ³  Rd  ³   ext    - extension of opcode   ³
³³ÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´   opcode - instruction code      ³
³³ ext ³opcode³    Rn   ³   Rm  ³  Rd  ³   cond   - 4-bit condition       ³
³³ÄÄÄÄÄÁÂÄÄÄÄÄÁÄÄÂÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄ´   offset - immediate offset      ³
³³ ext  ³ cond   ³     offset          ³                                  ³
³³ÄÄÄÄÄÂÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                                  ³
³³ ext ³       XXXXXXXXX               ³                                  ³
³³ÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ´                                  ³
³³ ext ³  offset        ³   Rn  ³  Rd  ³                                  ³
³³ÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÅÄÄÄÄÄÄÄÁÄÄÄÄÄÄ´                                  ³
³³ ext. opcode   ³  Rd  ³  offset      ³                                  ³
³³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                                  ³
³³ ext. opcode   ³  XXXXXXXXXXXXX      ³                                  ³
³³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                                  ³
³³ ext. opcode       ³     Rm / SBZ    ³                                  ³
³ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ %I32-bit Intructions set in format of {ext.i}[opcode.S]<X>:%i               ³
³ ADC          {0.i}[5]             Add with carry                        ³
³ ADD          {0.i}[4]             Add                                   ³
³ AND          {0.i}[0]             Bitwise AND                           ³
³ B            {  5}[0]             Branch                                ³
³ BL           {  5}[8]             Branch and link (analog of call)      ³
³ BIC          {0.i}[E]             Bit Clear                             ³
³ BKPT         {  1}[2]             Break-Point                           ³
³ BLX          {  5}[8]             Branch Link and Exchange (Thumb mode) ³
³ BLX          {  0}[9]<0>          Branch Link and Exchange (Thumb mode) ³
³ BX           {  0}[9]<1>          Branch Exchange (Thumb mode)          ³
³ CPD          {7.0}[FPU_op]        Coprocessor data processing           ³
³ CLZ          {0.1}[6]             Count Leading Zero                    ³
³ CMN          {0.i}[B.1]           Compare Negative                      ³
³ CMP          {0.i}[A.1]           Compare                               ³
³ EOR          {0.i}[1]             Exclusive OR                          ³
³ LDC          {  6}[punw.1]        Load coprocessor                      ³
³ LDM          {  5}[pu0w.1]        Load and multiply                     ³
³ LDM          {  5}[pu1w.1]        Load and multiply                     ³
³ LDR          {2.i}[pu0w.1]        Load register                         ³
³ LDRB         {2.i}[pu1w.1]        Load register byte                    ³
³ LDRBT        {2.i}[0u11.1]        Load register byte with translation   ³
³ LDRH         {  0}[pui1w.1]<B>    Load register halfword                ³
³ LDRSB        {  0}[pui1w.1]<F>    Load register signed halfword         ³
³ LDRT         {1.i}[0u10.1]        Load register with translation        ³
³ MCR          {E.0}[FPU_op.0]<1>   Load register to coprocessor          ³
³ MLA          {  0}[1]<9>          Multiply accumulate                   ³
³ MOV          {0.i}[E]             Move                                  ³
³ MRC          {E.1}[FPU_op.1]<1>   Load register from coprocessor        ³
³ MRS          {  0}[1R00]          Move PSR to GPR                       ³
³ MSR          {  1}[1R00.0] imm8   Move PSR from GPR                     ³
³ MSR          {  0}[1R00.0]<0>     Move PSR from GPR                     ³
³ MUL          {  0}[0]<9>          Multiply                              ³
³ MVN          {0.1}[F]             Move negative                         ³
³ ORR          {0.1}[C]             Logical OR                            ³
³ RSB          {0.i}[3]             Reverse substract                     ³
³ RSC          {0.i}[7]             Reverse substract with carry          ³
³ SBC          {0.i}[6]             Substract with carry                  ³
³ SMLAL        {0.i}[7]<9>          Signed Multiply Accumulate Long       ³
³ SMULL        {0.i}[6]<9>          Signed Multiply Long                  ³
³ STC          {  6}[punw.0]        Store coprocessor                     ³
³ STM          {  5}[pu0w]          Store multiply                        ³
³ STM          {  4}[pu10]0 rg.list Store multiply                        ³
³ STR          {1.i}[pu0w0]         Store register                        ³
³ STRB         {1.i}[pu1w0]         Store register byte                   ³
³ STRBT        {1.i}[0u110]         Store register byte with translation  ³
³ STRH         {  0}[puiw0]<A>      Store register halfword               ³
³ STRT         {  1}[0u010]         Store register with translation       ³
³ SUB          {0.i}[2]             Substract                             ³
³ SWI          {7.1}                Software interrupt                    ³
³ SWP          {0  }[8]0<9>         Swap                                  ³
³ SWPB         {0  }[A]0<9>         Swap byte                             ³
³ TEQ          {0.i}[9.1]           Test Equivalence                      ³
³ TST          {0.i}[8.1]           Test                                  ³
³ UMLAL        {  0}[5]<9>          Unsigned Multiply Accumulate Long     ³
³ UMULL        {  0}[4]<9>          Unsigned Multiply Long                ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ %IThumb instruction format in format {ext}<opcode>:%i                       ³
³ ADC          {010}[5]             Add with carry                        ³
³ ADD          {0E}                 Add                                   ³
³ ADD          {5}                  Add                                   ³
³ ADD          {0C}                 Add                                   ³
³ ADD          {08}[4]              Add                                   ³
³ ADD          {14}                 Add                                   ³
³ ADD          {16}[0]              Add                                   ³
³ AND          {010}[0]             Logical AND                           ³
³ ASR          {2}                  Arithmetic shift right                ³
³ ASR          {010}[4]             Arithmetic shift right                ³
³ B            {D}[cond]            Branch                                ³
³ B            {1}[B]               Branch                                ³
³ BIC          {010}[E]             Bit Clear                             ³
³ BKPT         {B}[E]               Breakpoint                            ³
³ BL           {7.h}                Branch and Link                       ³
³ BLX          {08}[F]              Branch, Link and eXchange             ³
³ BX           {08}[E]              Branch and eXchange                   ³
³ CMN          {08}[B]              Compare Negative                      ³
³ CMP          {05}                 Compare                               ³
³ CMP          {08}[A]              Compare                               ³
³ CMP          {08}[5.h1.h2]        Compare                               ³
³ EOR          {08}[1]              Exclusive OR                          ³
³ LDMIA        {19}                 Load Multiple Increment After         ³
³ LDR          {0D}                 Load Register                         ³
³ LDR          {2C}                 Load Register                         ³
³ LDR          {09}                 Load Register                         ³
³ LDR          {13}                 Load Register                         ³
³ LDRB         {0F}                 Load Register Byte                    ³
³ LDRB         {2E}                 Load Register Byte                    ³
³ LDRH         {11}                 Load Register Halfword                ³
³ LDRH         {2D}                 Load Register Halfword                ³
³ LDRSB        {2B}                 Load Register Signed Byte             ³
³ LDRSH        {2F}                 Load Register Signed Halfword         ³
³ LSL          {0}                  Logical Shift Left                    ³
³ LSL          {010}[2]             Logical Shift Left                    ³
³ LSR          {01}                 Logical Shift Right                   ³
³ LSR          {10}[3]              Logical Shift Right                   ³
³ MOV          {04}                 Move                                  ³
³ MOV          {0E}[0]              Move                                  ³
³ MOV          {45}                 Move                                  ³
³ MUL          {010}[D]             Multiply                              ³
³ MVN          {010}[F]             Move NOT                              ³
³ NEG          {010}[9]             Negate                                ³
³ ORR          {010}[C]             Logical OR                            ³
³ POP          {BC}[r]              Pop multiple registers                ³
³ PUSH         {B5}[r]              Push multiple registers               ³
³ ROR          {010}[7]             Rotate right register                 ³
³ SBC          {010}[4]             Substract with Carry                  ³
³ STMIA        {18}                 Store Multiply Increment After        ³
³ STR          {0C}                 Store Register                        ³
³ STR          {028}                Store Register                        ³
³ STR          {12}                 Store Register                        ³
³ STRB         {0E}                 Store Register Byte                   ³
³ STRB         {2A}                 Store Register Byte                   ³
³ STRH         {10}                 Store Register Halfword               ³
³ STRH         {10}                 Store Register Halfword               ³
³ STRH         {051}                Store Register Halfword               ³
³ SUB          {01F}                Substract                             ³
³ SUB          {07}                 Substract                             ³
³ SUB          {0D}                 Substract                             ³
³ SUB          {161}                Substract                             ³
³ SWI          {DF}                 Software Interrupt                    ³
³ TST          {010}[8]             Test                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ %IDSP extension%i.                                                          ³
³ Many digital signal processing (DSP) algorithms operate on arrays of    ³
³ 16-bit data, where the 16-bit value is to be interpreted as a signed    ³
³ fixed-point number with 15 binary places. Such values are sometimes     ³
³ called Q15 numbers, and represent numeric values ranging from -1 up to  ³
³ +1*2e-15.                                                               ³
³                                                                         ³
³ %I32-bit DSP Intructions set in format of {ext.i}[opcode.S]<X>:%i           ³
³ LDRD         {  0}[puiw0]<D>      Load pair of ARM registers            ³
³ MCRR         {  6}[2.0]<fpu>      Move pair registers to coprocessor    ³
³ MRRC         {  6}[2.1]<fpu>      Move pair registers from coprocessor  ³
³ PLD          {1,i}[1u101]<F>      Prefetch load double registers        ³
³ QADD         {  0}[8.0]<5>        Q-numbers Add with saturation         ³
³ QDADD        {  0}[A.0]<5>        Double Q-numbers & Add with saturation³
³ QDSUB        {  0}[B.0]<5>        Double Q-numbers & Substract          ³
³ QSUB         {  0}[9.0]<5>        Q-numbers Substract                   ³
³ SMLA<x><y>   {  0}[8.0]<1yx0>     Signed Multiply and Accumulate        ³
³ SMLAL<x><y>  {  0}[A.0]<1yx0>     Signed Multiply and Accumulate 16-bit ³
³ SMLAW<y>     {  0}[9.0]<1y00>     Signed Multiply and Accumulate words  ³
³ SMUL<x><y>   {  0}[B.0]<1yx0>     Unsigned Multiply and Accumulate      ³
³ SMULW<y>     {  0}[9.0]<1y10>     Unsigned Multiply and Accumulate words³
³ STRD         {  0}[puiw0]<F>      Store pair of ARM registers           ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ %IVector Floating-Point extension.%i                                        ³
³ The Vector Floating-Point (VFP) architecture is a coprocessor extension ³
³ to the ARM architecture. It provides single-precision and               ³
³ double-precision floating-point arithmetic, as defined by ANSI/IEEE Std.³
³ 754-1985 IEEE Standard for Binary Floating-Point Arithmetic.            ³
³                                                                         ³
³ To date, there has only been one major version of the VFP architecture  ³
³ (Version 1, or VFPv1). Double-precision support is optional, with its   ³
³ presence being indicated by the variant letter D. So the VFPv1D variant ³
³ has both single precision and double precision, while VFPv1xD supports  ³
³ single precision only. By default, double-precision support is present. ³
³
³ VFP has 32 general-purpose registers, each capable of holding a         ³
³ single-precision floating-point number or a 32-bit integer. In D variant³
³ of the architecture, these registers can also be used in pairs to hold  ³
³ up to 16 double-precision floating-point numbers. There are also three  ³
³ or more system registers:                                               ³
³ %BFPSID%b     Is read-only. It can be read to determine which implementation³
³           of the VFP architecture is being used.                        ³
³ %BFPSCR%b     Supplies all user-level status and control. Status bits hold  ³
³           comparison results and cumulative flags for floating-point    ³
³           exceptions. Control bits are provided to select rounding      ³
³           options and vector length/stride, and to enable floating-point³
³           exception traps.                                              ³
³ %BFPEXC%b     Contains a few bits for system-level status and control.      ³
³                                                                         ³
³ VFP instruction set in format {ext}[]opcode]<fpu_opcode>:               ³
³ FABSD      {E.1}[0.3.0]<B.1.1>  FP Absolute Value, Double-precision     ³
³ FABSS      {E.1}[x.3.0]<A.1.1>  FP Absolute Value, Single-precision     ³
³ FADDD      {E.0}[0.3]<B.0.0>    FP Addition, Double-precision           ³
³ FADDS      {E.0}[x.3]<A.0.0>    FP Addition, Single-precision           ³
³ FCMPD      {E.1}[0.3.4]<B.0.1>  FP Comparision, Double-precision        ³
³ FCMPS      {E.1}[x.3.4]<A.0.1>  FP Comparision, Single-precision        ³
³ FCMPED     {E.1}[0.3.4]<B.1.1>  FP Comparision, Double-precision for Nan³
³ FCMPES     {E.1}[x.3.4]<A.1.1>  FP Comparision, Single-precision for Nan³
³ FCMPEZD    {E.1}[0.3.5]<B.1.1>  FP Comparision, Double-precision for Zer³
³ FCMPEZS    {E.1}[x.3.5]<A.1.1>  FP Comparision, Single-precision for Zer³
³ FCMPZD     {E.1}[0.3.5]<B.0.1>  FP Comparision, Double-precision for Zer³
³ FCMPZS     {E.1}[x.3.5]<A.0.1>  FP Comparision, Single-precision for Zer³
³ FCPYD      {E.1}[0.3.0]<B.0.1>  FP Copy Double-precision                ³
³ FCPYS      {E.1}[x.3.0]<A.0.1>  FP Copy Single-precision                ³
³ FCVTDS     {E.1}[0.3.7]<A.1.1>  FP Conevrt Single to Double             ³
³ FCVTSD     {E.1}[x.3.7]<B.1.1>  FP Conevrt Double to Single             ³
³ FDIVD      {E.1}[0.0]<B.0.0>    FP Divide, Double-precision             ³
³ FDIVS      {E.1}[x.0]<A.0.0>    FP Divide, Single-precision             ³
³ FLDD       {D.u}[0.0.1]<B>      FP Load, Double-precision               ³
³ FLDS       {D.u}[x.0.1]<A>      FP Load, Single-precision               ³
³ FLDMD      {6.p}[u.0.w.1]<B>    FP Load, Multiple Double-precision      ³
³ FLDMS      {6.p}[u.0.w.1]<A>    FP Load, Multiple Single-precision      ³
³ FLDMX      {6.p}[u.0.w.1]<A>    FP Load, Multiple Unknown-precision     ³
³ FMACD      {E.0}[0.0]<B.0.0>    FP Multiply and Accumulate Double       ³
³ FMACS      {E.0}[x.0]<B.0.0>    FP Multiply and Accumulate Single       ³
³ FMDHR      {E.0}[2]<B.0.0.1>    FP Load High of Double from Register    ³
³ FMDLR      {E.0}[0]<B.0.0.1>    FP Load Low of Double from Register     ³
³ FMRDH      {E.0}[3]<B.0.0.1>    FP Load High of Double to Register      ³
³ FMRDL      {E.0}[1]<B.0.0.1>    FP Load Low of Double to Register       ³
³ FMRS       {E.1}[1]<A.x.0.1>    FP Load Single to Register              ³
³ FMRX       {E.F}[1]<A.0.0.1>    FP system FP-reg to Register            ³
³ FMSCD      {E.0}[0.1]<B.0.0>    FP Multiply and Substract Double        ³
³ FMSCS      {E.0}[x.1]<A.0.0>    FP Multiply and Substract Single        ³
³ FMSR       {E.0}[1]<A.x.0.1>    FP Load Single from Register            ³
³ FMSTAT     {E.F}[1.F]<A.0.0.1>  FP Move Status                          ³
³ FMULD      {E.0}[0.2]<B.0.0>    FP Multiply, Double-precision           ³
³ FMULS      {E.0}[x.2]<A.0.0>    FP Multiply, Single-precision           ³
³ FMXR       {E.E}<A.0.0.1>       FP system FP-reg from Register          ³
³ FNEGD      {E.1}[0.3.01]<B.0.1> FP Negate, Double-precision             ³
³ FNEGS      {E.1}[x.3.01]<A.0.1> FP Negate, Single-precision             ³
³ FNMACD     {E.0}[0.0]<B.0.1>    FP Negate Multiply And Accumulate Double³
³ FNMACS     {E.0}[x.0]<A.0.1>    FP Negate Multiply And Accumulate Single³
³ FNMSCD     {E.0}[0.1]<B.0.1>    FP Negate Multiply And Substract Double ³
³ FNMSCS     {E.0}[x.1]<A.0.1>    FP Negate Multiply And Substract Single ³
³ FNMULD     {E.0}[0.2]<B.0.1>    FP Negate Multiply Double               ³
³ FNMULS     {E.0}[x.2]<A.0.1>    FP Negate Multiply Single               ³
³ FSITOD     {E.1}[0.3.8]<B.1.1>  FP Convert Single-Interger to Double-FP ³
³ FSITOS     {E.1}[x.3.8]<A.1.1>  FP Convert Single-Interger to Single-FP ³
³ FSQRTD     {E.1}[0.3.1]<B.1.1>  FP Square Root, Double-precision        ³
³ FSQRTS     {E.1}[x.3.1]<A.1.1>  FP Square Root, Single-precision        ³
³ FSTD       {D.u}[0.0]<B>        FP Store, Double-precision              ³
³ FSTS       {D.u}[0.0]<A>        FP Store, Single-precision              ³
³ FSTMD      {6.p}[u.0.w.0]<B>    FP Load, Multiple Double-precision      ³
³ FSTMS      {6.p}[u.0.w.0]<A>    FP Load, Multiple Single-precision      ³
³ FSTMX      {6.p}[u.0.w.0]<B>    FP Load, Multiple Unknown-precision     ³
³ FSUBD      {E.0}[0.3]<B.0.1>    FP Substract, Double-precision          ³
³ FSUBS      {E.0}[0.3]<B.0.1>    FP Substract, Single-precision          ³
³ FTOSID     {E.1}[x.3.B]<B.0.1>  FP Convert Double-FP to Single-Interger ³
³ FTOSIZD    {E.1}[x.3.B]<B.1.1>  FP Convert Double-FP to Single-Interger ³
³ FTOSIS     {E.1}[x.3.B]<A.0.1>  FP Convert Single-FP to Single-Interger ³
³ FTOSIZS    {E.1}[x.3.B]<A.1.1>  FP Convert Single-FP to Single-Interger ³
³ FTOUID     {E.1}[x.3.C]<B.0.1>  FP Convert Double-FP to USingle-Interger³
³ FTOUIZD    {E.1}[x.3.C]<B.1.1>  FP Convert Double-FP to USingle-Interger³
³ FTOUIS     {E.1}[x.3.C]<A.0.1>  FP Convert Single-FP to USingle-Interger³
³ FTOUIZS    {E.1}[x.3.C]<A.1.1>  FP Convert Single-FP to USingle-Interger³
³ FUITOD     {E.1}[x.3.8]<B.1.1>  FP Convert USingle-Interger to Double-FP³
³ FUITOS     {E.1}[x.3.8]<A.1.1>  FP Convert USingle-Interger to Single-FP³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ %BIntel's XScale extension%b                                                ³
³ XScale is Intel Wireless MMX 2 coprocessor for ARM architecture.        ³
³ To use the Intel Wireless MMX 2 coprocessor the coprocessors need to    ³
³ be enabled in the coprocessor access register which is located in       ³
³ register 15 of coprocessor 15. Both bits 0 and 1 of this register       ³
³ (corresponding to coprocessor 0 and 1) should be set to a 1 to enable   ³
³ access to the Intel Wireless MMX 2 coprocessor. If the Intel Wireless   ³
³ MMX 2 coprocessor is not enabled in this way, all Intel Wireless MMX 2  ³
³ coprocessor instructions take the undefined instruction trap.           ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ XScale coprocessor has 16 64-bit registers wih names: %IwR0-wR15%i          ³
³ In addition Intel XScale coprocessor has additional registers:          ³
³ %IwCASF%i        - Arithmetic SIMD flags.                                   ³
³ %IwCSSF%i        - Saturation status register.                              ³
³ %IwCGR0-wCGR3%i  - 32-bit GPR used for alignment, and shift.                ³
³ %IwCID%i         - coprocessor ID.                                          ³
³ %IwCon%i         - coprocessor control regsiter.                            ³
³                                                                         ³
³ All instructions (except load/store) of XScale coprocessor are 4-byte   ³
³ long. The fields of instruction are located as follow:                  ³
³                                                                         ³
³    31-28   27-24  24-20   19-16 15-12 11-8   7-4   3-0                  ³
³   ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿                ³
³   ³cond  ³1110  ³opcode1³ wRn  ³ wRd ³cpnum³opc2 ³ wRS ³                ³
³   ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÙ                ³
³                                                                         ³
³ Below presented list of XScale insns in form: opcode1.cpnum.opc2:       ³
³ TANDC<B,H.W>  ww01.0001.0011    Performs AND operation across wCASF     ³
³ TBCST<B,H.W>  0100.0000.ww01    Broadcast value from ARM to SIMD reg    ³
³ TEXTRC<B,H.W> ww01.0001.0111    Extracts fields from wCASF to CPSR      ³
³ TEXTRC<B,H.W> ww01.0001.0111    Extracts fields from wCASF to CPSR      ³
³ TEXTRM<B,H.W> ww01.0000.0111    Extracts fields SIMD to ARM reg         ³
³ TINSR<B,H.W>  0110.0000.ww01    Inserts fields from ARM to SIMD reg     ³
³ TMIA          0010.<1000>000..1 Multiply and Accumulate 32-bit operands ³
³ TMIAPH        0010.<1000>000..1 Multiply and Accumulate 16-bit operands ³
³ TMIA<T,B>     0010.<11xy>000..1 Multiply and Accumulate 16-bit operands ³
³ TMOVMSK<B,H,W>ww01.0000.0011    Transfers Mask from SIMD to ARM reg     ³
³ TORC<B,H,W>   ww01.0001.0101    Performs OR operation across wCASF      ³
³ TORVSC<B,H,W> ww01.0001.0101    Performs OR operation across wCSSF      ³
³ WABS<B,H,W>   ww10.0001.1100    Vector Absolute Value                   ³
³ WABSDIFF<B,H,W>ww01.0001.1100   Vector Absolute Value of the difference ³
³ WACC<B,H,W>   ww00.0001.1100    Vector Accumulate                       ³
³ WADD<B,H,W>   wwss.0001.1000    Vector Addition                         ³
³ WADDSUBHX     1010.0001.1010    Vector Complex Addition/Substraction    ³
³ WALIGNI       0vvv.0000.0010    Extract 64-bit and store with off as imm³
³ WALIGNR       10vv.0000.0010    Extract 64-bit and store with off as reg³
³ WAND          0010.0000.0000    Vector AND                              ³
³ WANDN         0011.0000.0000    Vector AND and NOT                      ³
³ WAVG2<B,H>{R} 1h0r.0000.0000    Vector 2-pixel average with(out) Roundng³
³ WAVG4{R}      010r.0000.0000    Vector 4-pixel average with(out) Roundng³
³ WCMPEQ<B,H,W> ww00.0000.0110    Vector Equality Comparision             ³
³ WCMPGT<B,H,W> wws1.0000.0110    Vector Magnitude Comparision            ³
³ WLDR<B,H,W,D> <110>[punw1]{000M}Vector Load from memory                 ³
³ WMAC<U,S>     01sz.0001.0000    Vector Multiplication and ACcumulate    ³
³ WMADD<U,S>    nnsx.0001.0000    Vector Multiplication and ADdition      ³
³ WMAX<B,H,W>   wws0.0001.0110    Vector Maximum selection                ³
³ WMERGE        cba0.0000.1000    Vector Merge elements                   ³
³ WMIA<T,B>     0nxy.0000.1010    16-bit parallel multiply-Negate after Ac³
³ WMIAW<T,B>    1nxy.0000.1010    32-bit parallel multiply-Negate after Ac³
³ WMIN<B,H,W>   wws1.0001.0110    Vector Minimum selection                ³
³ WMUL<U,S>     rrsf.0001.0000    Vector 16-bit Multiplication            ³
³ WMULW<U,S>    1fsr.0001.1100    Vector 32-bit Multiplication            ³
³ WOR           0000.0000.0000    Vector OR                               ³
³ WPACK<B,H,W>  wwss.0000.1000    Vector Pack Data                        ³
³ WQMIAxy       1nxy.0000.1010    Fractional 16-bit MUL-NEG after 32bt Acc³
³ WQMULM{R}     00r1.0000.1000    Vector 16-bit MUL with Round to nearest ³
³ WQMULWM{R}    11r0.0000.1110    Vector 32-bit MUL with Round to nearest ³
³ WROR<B,H,W>   ww11.000g.0100    Vector Logical Rotate Right             ³
³ WSAD<B,H>{Z}  0h0z.0001.0010    Vector Summ of Absolute Difference {w Zr³
³ WSHUFH        ddcc.0001.1110.ba Vector Shuffle 16-bit values            ³
³ WSLL<H,W,D>   ww01.000g.0100    Vector Logical Shift Left               ³
³ WSRA<H,W,D>   ww00.000g.0100    Vector Arithmetic Shift Right           ³
³ WSRL<H,W,D>   ww10.000g.0100    Vector Logical Shift Right              ³
³ WSTR<B,H,W,D> <110>[punw0]{000M}Vector Store to memory                  ³
³ WSUB<B,H,W>   wwss.0001.1010    Vector Substract                        ³
³ WSUBADDHX     1011.0001.1100    Vector Complex Substraction/Addition    ³
³ WUNPCKEH<B,H,W>wws0.0000.1100   Vector Unpack from Top Half of SIMD Reg ³
³ WUNPCKIH<B,H,W>ww01.0000.1100   Vector Unpack from Top Half Interleaved ³
³ WUNPCKEL<B,H,W>wws0.0000.1110   Vector Unpack from Low Half of SIMD Reg ³
³ WUNPCKIL<B,H,W>ww01.0000.1110   Vector Unpack from Low Half Interleaved ³
³ WXOR          0001.0000.0000    Vector bitwise XOR                      ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Pseudo instructions:                                                    ³
³ WMOV   r1,r2  is alias for      WOR r1,r2,r2                            ³
³ WZERO  r1     is alias for      WANDN r1,r1,r1                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
